package br.com.pointel.jarch.data;

import java.io.Serializable;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.Objects;
import br.com.pointel.jarch.flow.FixVals;
import br.com.pointel.jarch.mage.WizChars;
import br.com.pointel.jarch.mage.WizData;

public class TableHead implements Data {

    public String catalog;
    public String schema;
    public String name;
    public String alias;

    public TableHead() {
    }

    public TableHead(String name) {
        this.name = name;
    }

    public TableHead(String schema, String name) {
        this.schema = schema;
        this.name = name;
    }

    public TableHead(String catalog, String schema, String name) {
        this.catalog = catalog;
        this.schema = schema;
        this.name = name;
    }

    public TableHead(String catalog, String schema, String name, String alias) {
        this.catalog = catalog;
        this.schema = schema;
        this.name = name;
        this.alias = alias;
    }

    public String getReferenceName() {
        return this.alias != null && !this.alias.isEmpty() ? this.alias : this.getCatalogSchemaName();
    }

    public String getSchemaName() {
        return WizChars.sum(".", this.schema, this.name);
    }

    public String getCatalogSchemaName() {
        return WizChars.sum(".", this.catalog, this.schema, this.name);
    }

    public String getNameForFile() {
        return WizChars.sum(".", this.catalog, this.schema, this.name);
    }

    public Table getTable(Connection connection) throws Exception {
        var fieldList = new ArrayList<Field>();
        var keyPrimaryList = new ArrayList<KeyPrimary>();
        var keyForeignList = new ArrayList<KeyForeign>();
        var table = new Table(this, fieldList, keyPrimaryList, keyForeignList);
        var meta = connection.getMetaData();
        var primaryRS = meta.getPrimaryKeys(this.catalog, this.schema, this.name);
        while (primaryRS.next()) {
            var keyName = primaryRS.getString("PK_NAME");
            var keyPrimary = keyPrimaryList.stream()
                    .filter(p -> Objects.equals(p.name, keyName))
                    .findFirst().orElse(null);
            if (keyPrimary == null) {
                keyPrimary = new KeyPrimary(keyName, new ArrayList<>());
                keyPrimaryList.add(keyPrimary);
            }
            var sequence = primaryRS.getInt("KEY_SEQ");
            var columnName = primaryRS.getString("COLUMN_NAME");
            var keyColumn = new OrdName(sequence, columnName);
            keyPrimary.columnList.add(keyColumn);
        }
        var columnsRS = meta.getColumns(this.catalog, this.schema, this.name, "%");
        while (columnsRS.next()) {
            final var fieldOrd = columnsRS.getInt("ORDINAL_POSITION");
            final var fieldName = columnsRS.getString("COLUMN_NAME");
            final var fieldNature = WizData.getNatureOfSQL(columnsRS.getInt("DATA_TYPE"));
            final var fieldSize = columnsRS.getInt("COLUMN_SIZE");
            final var fieldPrecision = columnsRS.getInt("DECIMAL_DIGITS");
            final var fieldNotNull = "NO".equals(columnsRS.getString("IS_NULLABLE"));
            final var fieldAutoIncrement = !"NO".equals(columnsRS.getString("IS_AUTOINCREMENT"));
            final var fieldAutoGenerated = !"NO".equals(columnsRS.getString("IS_GENERATEDCOLUMN"));
            final var fieldKeyPrimary = keyPrimaryList.stream().anyMatch(k -> k.columnList.stream().anyMatch(c -> Objects.equals(c.name, fieldName)));
            final var field = new Field(fieldOrd, fieldName, fieldNature, fieldSize, fieldPrecision, fieldNotNull, fieldAutoIncrement, fieldAutoGenerated, fieldKeyPrimary);
            field.setTable(table);
            fieldList.add(field);
        }
        var foreignRS = meta.getImportedKeys(this.catalog, this.schema, this.name);
        while (foreignRS.next()) {
            var inName = foreignRS.getString("FK_NAME");
            var outName = foreignRS.getString("PK_NAME");
            var keyForeign = keyForeignList.stream()
                    .filter(f -> Objects.equals(f.inName, inName) && Objects.equals(f.outName, outName))
                    .findFirst().orElse(null);
            if (keyForeign == null) {
                var outCatalog = foreignRS.getString("PKTABLE_CAT");
                var outSchema = foreignRS.getString("PKTABLE_SCHEM");
                var outTable = foreignRS.getString("PKTABLE_NAME");
                var outTableHead = new TableHead(outCatalog, outSchema, outTable);
                keyForeign = new KeyForeign(inName, outName, outTableHead, new ArrayList<>());
                keyForeignList.add(keyForeign);
            }
            var sequence = foreignRS.getInt("KEY_SEQ");
            var inColumn = foreignRS.getString("FKCOLUMN_NAME");
            var outColumn = foreignRS.getString("PKCOLUMN_NAME");
            var match = new Match(sequence, inColumn, outColumn);
            keyForeign.matchList.add(match);
        }
        return table;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof TableHead)) {
            return false;
        }
        TableHead tableHead = (TableHead) o;
        return Objects.equals(catalog, tableHead.catalog) && Objects.equals(schema, tableHead.schema) && Objects.equals(name, tableHead.name) && Objects.equals(alias, tableHead.alias);
    }

    @Override
    public int hashCode() {
        return Objects.hash(catalog, schema, name, alias);
    }

    @Override
    public String toString() {
        return this.toChars();
    }

    public static TableHead fromChars(String chars) {
        return Data.fromChars(chars, TableHead.class);
    }

}
