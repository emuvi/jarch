package br.com.pointel.jarch.data;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.Objects;
import com.google.gson.Gson;
import br.com.pointel.jarch.flow.FixVals;
import br.com.pointel.jarch.mage.WizChars;
import br.com.pointel.jarch.mage.WizData;

public class TableHead implements FixVals {

    public String catalog;
    public String schema;
    public String name;
    public String alias;

    public TableHead() {}

    public TableHead(String name) {
        this.name = name;
    }

    public TableHead(String schema, String name) {
        this.schema = schema;
        this.name = name;
    }

    public TableHead(String catalog, String schema, String name) {
        this.catalog = catalog;
        this.schema = schema;
        this.name = name;
    }

    public TableHead(String catalog, String schema, String name, String alias) {
        this.catalog = catalog;
        this.schema = schema;
        this.name = name;
        this.alias = alias;
    }

    public String getReferenceName() {
        return this.alias != null && !this.alias.isEmpty() ? this.alias : this.getCatalogSchemaName();
    }

    public String getSchemaName() {
        return WizChars.sum(".", this.schema, this.name);
    }

    public String getCatalogSchemaName() {
        return WizChars.sum(".", this.catalog, this.schema, this.name);
    }

    public String getNameForFile() {
        return WizChars.sum(".", this.catalog, this.schema, this.name);
    }

    public Table getTable(Connection connection) throws Exception {
        var fieldList = new ArrayList<Field>();
        var keyPrimaryList = new ArrayList<KeyPrimary>();
        var keyForeignList = new ArrayList<KeyForeign>();
        var table = new Table(this, fieldList, keyPrimaryList, keyForeignList);
        var meta = connection.getMetaData();
        var primaryRS = meta.getPrimaryKeys(this.catalog, this.schema, this.name);
        while (primaryRS.next()) {
            var keyName = primaryRS.getString("PK_NAME");
            var keyPrimary = keyPrimaryList.stream()
                    .filter(p -> Objects.equals(p.name, keyName))
                    .findFirst().orElse(null);
            if (keyPrimary == null) {
                keyPrimary = new KeyPrimary(keyName, new ArrayList<>());
                keyPrimaryList.add(keyPrimary);
            }
            var sequence = primaryRS.getInt("KEY_SEQ");
            var columnName = primaryRS.getString("COLUMN_NAME");
            var keyColumn = new OrdName(sequence, columnName);
            keyPrimary.columnList.add(keyColumn);
        }
        var columnsRS = meta.getColumns(this.catalog, this.schema, this.name, "%");
        while (columnsRS.next()) {
            var field = new Field();
            field.ord = columnsRS.getInt("ORDINAL_POSITION");
            field.name = columnsRS.getString("COLUMN_NAME");
            field.nature = WizData.getNatureOfSQL(columnsRS.getInt("DATA_TYPE"));
            field.size = columnsRS.getInt("COLUMN_SIZE");
            field.precision = columnsRS.getInt("DECIMAL_DIGITS");
            field.notNull = "NO".equals(columnsRS.getString("IS_NULLABLE"));
            field.autoIncrement = !"NO".equals(columnsRS.getString("IS_AUTOINCREMENT"));
            field.autoGenerated = !"NO".equals(columnsRS.getString("IS_GENERATEDCOLUMN"));
            field.keyPrimary = keyPrimaryList.stream()
                    .anyMatch(k -> k.columnList.stream()
                            .anyMatch(c -> Objects.equals(c.name, field.name)));
            field.table = table;
            fieldList.add(field);
        }
        var foreignRS = meta.getImportedKeys(this.catalog, this.schema, this.name);
        while (foreignRS.next()) {
            var inName = foreignRS.getString("FK_NAME");
            var outName = foreignRS.getString("PK_NAME");
            var keyForeign = keyForeignList.stream()
                    .filter(f -> Objects.equals(f.inName, inName) && Objects.equals(f.outName, outName))
                    .findFirst().orElse(null);
            if (keyForeign == null) {
                var outCatalog = foreignRS.getString("PKTABLE_CAT");
                var outSchema = foreignRS.getString("PKTABLE_SCHEM");
                var outTable = foreignRS.getString("PKTABLE_NAME");
                var outTableHead = new TableHead(outCatalog, outSchema, outTable);
                keyForeign = new KeyForeign(inName, outName, outTableHead, new ArrayList<>());
                keyForeignList.add(keyForeign);
            }
            var sequence = foreignRS.getInt("KEY_SEQ");
            var inColumn = foreignRS.getString("FKCOLUMN_NAME");
            var outColumn = foreignRS.getString("PKCOLUMN_NAME");
            var match = new Match(sequence, inColumn, outColumn);
            keyForeign.matchList.add(match);
        }
        return table;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof TableHead)) {
            return false;
        }
        TableHead registry = (TableHead) o;
        return Objects.equals(catalog, registry.catalog)
                        && Objects.equals(schema, registry.schema)
                        && Objects.equals(name, registry.name)
                        && Objects.equals(alias, registry.alias);
    }

    @Override
    public int hashCode() {
        return Objects.hash(catalog, schema, name, alias);
    }

    @Override
    public String toString() {
        return new Gson().toJson(this);
    }

    public static TableHead fromString(String json) {
        return new Gson().fromJson(json, TableHead.class);
    }

}
