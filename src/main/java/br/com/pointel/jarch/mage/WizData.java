package br.com.pointel.jarch.mage;

import java.io.PrintStream;
import java.math.BigDecimal;
import java.sql.Blob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Objects;
import com.google.gson.Gson;
import br.com.pointel.jarch.data.Field;
import br.com.pointel.jarch.data.KeyForeign;
import br.com.pointel.jarch.data.KeyPrimary;
import br.com.pointel.jarch.data.Match;
import br.com.pointel.jarch.data.Nature;
import br.com.pointel.jarch.data.OrdName;
import br.com.pointel.jarch.data.Table;
import br.com.pointel.jarch.data.TableHead;

public class WizData {

    private static final Gson gson = new Gson();

    private WizData() {
    }

    public static String toChars(Object data) {
        return gson.toJson(data);
    }

    public static <T> T fromChars(String chars, Class<T> clazz) {
        return gson.fromJson(chars, clazz);
    }

    public static Table getTable(TableHead tableHead, Connection connection) throws Exception {
        var fieldList = new ArrayList<Field>();
        var keyPrimaryList = new ArrayList<KeyPrimary>();
        var keyForeignList = new ArrayList<KeyForeign>();
        var table = new Table(tableHead, fieldList, keyPrimaryList, keyForeignList);
        var meta = connection.getMetaData();
        var primaryRS = meta.getPrimaryKeys(tableHead.catalog, tableHead.schema, tableHead.name);
        while (primaryRS.next()) {
            var keyName = primaryRS.getString("PK_NAME");
            var keyPrimary = keyPrimaryList.stream()
                    .filter(p -> Objects.equals(p.name, keyName))
                    .findFirst().orElse(null);
            if (keyPrimary == null) {
                keyPrimary = new KeyPrimary(keyName, new ArrayList<>());
                keyPrimaryList.add(keyPrimary);
            }
            var sequence = primaryRS.getInt("KEY_SEQ");
            var columnName = primaryRS.getString("COLUMN_NAME");
            var keyColumn = new OrdName(sequence, columnName);
            keyPrimary.columnList.add(keyColumn);
        }
        var columnsRS = meta.getColumns(tableHead.catalog, tableHead.schema, tableHead.name, "%");
        while (columnsRS.next()) {
            final var fieldOrd = columnsRS.getInt("ORDINAL_POSITION");
            final var fieldName = columnsRS.getString("COLUMN_NAME");
            final var fieldNature = WizData.getNatureOfSQL(columnsRS.getInt("DATA_TYPE"));
            final var fieldSize = columnsRS.getInt("COLUMN_SIZE");
            final var fieldPrecision = columnsRS.getInt("DECIMAL_DIGITS");
            final var fieldNotNull = "NO".equals(columnsRS.getString("IS_NULLABLE"));
            final var fieldAutoIncrement = !"NO".equals(columnsRS.getString("IS_AUTOINCREMENT"));
            final var fieldAutoGenerated = !"NO".equals(columnsRS.getString("IS_GENERATEDCOLUMN"));
            final var fieldKeyPrimary = keyPrimaryList.stream().anyMatch(k -> k.columnList.stream().anyMatch(c -> Objects.equals(c.name, fieldName)));
            final var field = new Field(fieldOrd, fieldName, fieldNature, fieldSize, fieldPrecision, fieldNotNull, fieldAutoIncrement, fieldAutoGenerated, fieldKeyPrimary);
            field.setTable(table);
            fieldList.add(field);
        }
        var foreignRS = meta.getImportedKeys(tableHead.catalog, tableHead.schema, tableHead.name);
        while (foreignRS.next()) {
            var inName = foreignRS.getString("FK_NAME");
            var outName = foreignRS.getString("PK_NAME");
            var keyForeign = keyForeignList.stream()
                    .filter(f -> Objects.equals(f.inName, inName) && Objects.equals(f.outName, outName))
                    .findFirst().orElse(null);
            if (keyForeign == null) {
                var outCatalog = foreignRS.getString("PKTABLE_CAT");
                var outSchema = foreignRS.getString("PKTABLE_SCHEM");
                var outTable = foreignRS.getString("PKTABLE_NAME");
                var outTableHead = new TableHead(outCatalog, outSchema, outTable);
                keyForeign = new KeyForeign(inName, outName, outTableHead, new ArrayList<>());
                keyForeignList.add(keyForeign);
            }
            var sequence = foreignRS.getInt("KEY_SEQ");
            var inColumn = foreignRS.getString("FKCOLUMN_NAME");
            var outColumn = foreignRS.getString("PKCOLUMN_NAME");
            var match = new Match(sequence, inColumn, outColumn);
            keyForeign.matchList.add(match);
        }
        return table;
    }

    public static void printColumnsNamesAndNatures(ResultSet results) throws SQLException {
        printColumnsNamesAndNatures(results, System.out);
    }

    public static void printColumnsNamesAndNatures(ResultSet results, PrintStream out) throws SQLException {
        var meta = results.getMetaData();
        for (int i = 1; i <= meta.getColumnCount(); i++) {
            out.println(String.format("[%d] %s : %s",
                    i, meta.getColumnName(i), String.valueOf(WizData.getNatureOfSQL(meta.getColumnType(i)))));
        }
    }

    public static void printAllValues(ResultSet results) throws SQLException {
        printAllValues(results, System.out);
    }

    public static void printAllValues(ResultSet results, PrintStream out) throws SQLException {
        var count = results.getMetaData().getColumnCount();
        while (results.next()) {
            var line = new StringBuilder();
            for (int i = 1; i <= count; i++) {
                if (i > 1) {
                    line.append(" | ");
                }
                line.append(String.valueOf(results.getObject(i)));
            }    
            out.println(line.toString());
        }
    }
    
    public static String[] getColumnNames(ResultSet results) throws SQLException {
        var meta = results.getMetaData();
        var names = new String[meta.getColumnCount()];
        for (int i = 1; i <= names.length; i++) {
            names[(i - 1)] = meta.getColumnName(i);
        }
        return names;
    }

    public static Nature[] getNaturesFrom(ResultSet results) throws SQLException {
        var meta = results.getMetaData();
        var natures = new Nature[meta.getColumnCount()];
        for (int i = 1; i <= natures.length; i++) {
            natures[(i - 1)] = WizData.getNatureOfSQL(meta.getColumnType(i));
        }
        return natures;
    }

    public static Nature getNatureOfSQL(int jdbcType) {
        switch (jdbcType) {
            case 16: return Nature.Bool;
            case -7: return Nature.Bit;
            case -6: return Nature.Byte;
            case 5: return Nature.Small;
            case 4: return Nature.Int;
            case -5: return Nature.Long;
            case 6: return Nature.Float;
            case 7: return Nature.Real;
            case 8: return Nature.Double;
            case 2, 3: return Nature.Numeric;
            case 1, -15: return Nature.Char;
            case 12, -1, -9, -16: return Nature.Chars;
            case 91: return Nature.Date;
            case 92, 2013: return Nature.Time;
            case 93, 2014: return Nature.Timestamp;
            case -2, -3, -4: return Nature.Bytes;
            case 2004: return Nature.Blob;
            case 2005: return Nature.Text;
            case 2000: return Nature.Object;
            default: throw new UnsupportedOperationException("Could not identify the data nature of jdbc type: " + jdbcType);
        }
    }

    public static Object getValueFrom(Nature nature, String formatted) throws Exception {
        if (formatted == null || formatted.isEmpty()) {
            return null;
        }
        switch (nature) {
            case Bool:
            case Bit:
                return Boolean.parseBoolean(formatted);
            case Byte:
                return Byte.parseByte(formatted);
            case Int:
            case Serial:
                return Integer.parseInt(formatted);
            case Long:
            case BigSerial:
                return Long.parseLong(formatted);
            case Float:
            case Real:
                return Float.parseFloat(formatted);
            case Double:
            case Numeric:
                return Double.parseDouble(formatted);
            case Char:
                return formatted.charAt(0);
            case Chars:
            case Text:
                return formatted;
            case Date:
                return WizDate.parseDate(formatted);
            case Time:
                return WizDate.parseTime(formatted);
            case Timestamp:
                return WizDate.parseTimestamp(formatted);
            case Bytes:
            case Blob:
                return WizBytes.decodeFromBase64(formatted);
            default:
                throw new Exception("DataType Not Supported.");
        }
    }

    public static String formatValue(Nature nature, Object value) throws Exception {
        if (value == null) {
            return "";
        }
        switch (nature) {
            case Bool:
            case Bit:
            case Byte:
            case Tiny:
            case Small:
            case Int:
            case Long:
            case Float:
            case Real:
            case Double:
            case Numeric:
            case Char:
            case Chars:
            case Text:
                return String.valueOf(value);
            case Date:
                return WizDate.formatDate(WizDate.get(value));
            case Time:
                return WizDate.formatTime(WizDate.get(value));
            case Timestamp:
                return WizDate.formatTimestamp(WizDate.get(value));
            case Bytes:
            case Blob:
                return WizBytes.encodeToBase64(WizBytes.get(value));
            default:
                throw new Exception("DataType Not Supported.");
        }
    }

    public static Boolean getBoolean(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof Boolean) {
            return (Boolean) data;
        }
        throw new RuntimeException("Could not convert to Boolean from class: " + data
                        .getClass().getCanonicalName());
    }

    public static Byte getByte(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof Byte) {
            return (Byte) data;
        }
        throw new RuntimeException("Could not convert to Byte from class: " + data
                        .getClass().getCanonicalName());
    }

    public static Short getShort(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof Short) {
            return (Short) data;
        }
        throw new RuntimeException("Could not convert to Short from class: " + data
                        .getClass().getCanonicalName());
    }

    public static Integer getInteger(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof Integer) {
            return (Integer) data;
        }
        throw new RuntimeException("Could not convert to Integer from class: " + data
                        .getClass().getCanonicalName());
    }

    public static Long getLong(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof Long) {
            return (Long) data;
        }
        throw new RuntimeException("Could not convert to Long from class: " + data
                        .getClass().getCanonicalName());
    }

    public static Float getFloat(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof Float) {
            return (Float) data;
        }
        throw new RuntimeException("Could not convert to Float from class: " + data
                        .getClass().getCanonicalName());
    }

    public static Double getDouble(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof Double) {
            return (Double) data;
        }
        throw new RuntimeException("Could not convert to Double from class: " + data
                        .getClass().getCanonicalName());
    }

    public static BigDecimal getBigDecimal(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof BigDecimal) {
            return (BigDecimal) data;
        }
        throw new RuntimeException("Could not convert to BigDecimal from class: " + data
                        .getClass().getCanonicalName());
    }

    public static String getString(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof String) {
            return (String) data;
        }
        return data.toString();
    }

    public static Date getDate(Object data) throws Exception {
        return new Date(WizDate.get(data).getTime());
    }

    public static Time getTime(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof Time) {
            return (Time) data;
        }
        throw new RuntimeException("Could not convert to Time from class: " + data
                        .getClass().getCanonicalName());
    }

    public static Timestamp getTimestamp(Object data) {
        if (data == null) {
            return null;
        }

        if (data instanceof Timestamp) {
            return (Timestamp) data;
        }
        throw new RuntimeException("Could not convert to Timestamp from class: " + data
                        .getClass().getCanonicalName());
    }

    public static byte[] getBytes(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof byte[]) {
            return (byte[]) data;
        }
        throw new RuntimeException("Could not convert to Bytes from class: " + data
                        .getClass().getCanonicalName());
    }

    public static Blob getBlob(Object data) {
        if (data == null) {
            return null;
        }
        if (data instanceof Blob) {
            return (Blob) data;
        }
        throw new RuntimeException("Could not convert to Blob from class: " + data
                        .getClass().getCanonicalName());
    }

    public static void setParams(PreparedStatement statement, Object[] params)
                    throws Exception {
        for (int i = 0; i < params.length; i++) {
            statement.setObject(i + 1, params[i]);
        }
    }
}
